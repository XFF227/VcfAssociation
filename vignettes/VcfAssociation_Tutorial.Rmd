---
title: "VcfAssociation_Tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{VcfAssociation_Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  fig.width  = 10,
  fig.height = 7,
  fig.align  = "center",
  dpi        = 350,
  out.width  = "70%"
)
```

## Introduction

The **VcfAssociation** package provides a light-weight workflow for
performing variant–phenotype association analyses starting from annotated
VCF files. The typical steps are:

1. Read a VCF file and extract variant and genotype tables.
2. Generate or import phenotype data.
3. Merge phenotypes and genotypes by sample ID.
4. Run single-variant regression (GWAS-style).
5. Run gene/region-level models using selected variants.
6. Visualize results with Manhattan and forest plots.

In this vignette, we demonstrate the workflow using a small toy VCF file
included with the package and explain what each figure represents in the
context of the data being analyzed.

## Installation

If the package is available on CRAN, it can be installed with:

```r
install.packages("VcfAssociation")
```

If you are installing from GitHub, you can use:

```r
# install.packages("devtools")
devtools::install_github("XFF227/VcfAssociation")
```

Once installed, load the package:

```{r setup}
library(VcfAssociation)
```

## Reading VCF files

Users can read an input VCF file and obtain both **variant information**
and **genotype data** with `read_vcf()`.

```{r}
vcf_path <- system.file("extdata", "toy.vcf",
                        package = "VcfAssociation", mustWork = TRUE)
vcf <- read_vcf(vcf_path)

geno_data <- vcf$genotypes
head(geno_data, 5)
```

The `geno_data` object is a long-format table where each row corresponds
to one sample at one locus, with an ALT-allele dosage column. This is
the format used by downstream functions in the package.

The same call also returns a **variant table**, which summarizes each
locus once:

```{r}
variants <- vcf$variants
head(variants, 5)
```

Here, each row corresponds to a unique genomic position (e.g. `CHROM`,
`POS`, `REF`, `ALT`) present in the toy VCF. These variant coordinates
will later be used to choose variants for gene/region-level models or
for displaying GWAS results.

## Generating and reading phenotype data

If you already have a phenotype file, you can load and merge it directly with genotype data using read_phenotypes().
If not, you can create one with generate_phenotype(), which constructs a simple binary phenotype (e.g., carrier status) based on a variant of interest in the VCF file.

In this example, we generate a **carrier status phenotype** (0/1) based
on a single variant at `chr12:11161`:

```{r}
pheno_df <- generate_phenotype(
  vcf_path,
  chrom = "chr12",
  pos   = 11161,
  model = "carrier"
)
head(pheno_df, 5)
```

We can then write this phenotype table to a temporary CSV file and merge it with the genotype table using read_phenotypes().
This function reads the phenotype file (such as one generated by generate_phenotype()) and merges it with the genotype data returned by read_vcf() using sample IDs as keys.
It produces a unified data frame that contains both phenotype and genotype information for each sample.

```{r}
tmpfile <- tempfile(fileext = ".csv")
write.csv(pheno_df, tmpfile, row.names = FALSE)

ph <- read_phenotypes(
  pheno_path = tmpfile,
  id_col    = "sample",
  genotypes = geno_data
)

head(ph$merged[16:20, ])
```

The object `ph` is a list:

* `ph$merged` is the main merged table used by other functions.
  It contains one row per sample–variant combination with both phenotype
  and dosage data.
* `ph$gaps` reports any sample IDs that appear only in the phenotype file
  or only in the genotype table.

In the context of this toy example, `ph$merged` represents a small
synthetic cohort in which the carrier status for one variant
(`chr12:11161`) is used as the phenotype, and the remaining variants in
the VCF are treated as candidate predictors.

## Gene/region-level models (phenotype ~ selected variants)

Sometimes we want to jointly model a set of variants (e.g. within a
gene or a region) instead of testing each variant individually.
This is handled by `prepare_list()` followed by `build_model()` and
visualized with `forest_plot()`.

### Step 1: Select variants and prepare per-variant data

We first specify a small set of variants of interest and create a list
of data frames, one per variant:

```{r}
variants_df <- data.frame(
  CHROM = c("chr12", "chr12", "chr12"),
  POS   = c(10537, 12372, 12180)
)

df_list_sel <- prepare_list(
  ph,
  variants   = variants_df,
  phenotypes = "phenotype"
)

names(df_list_sel)
```

Each element of `df_list_sel` contains:

* the selected variant’s dosage for all samples,
* the phenotype (`phenotype`), and
* any covariates (if provided).

In the context of the toy data, these three variants might be thought of
as belonging to the same hypothetical gene or locus whose joint
association with the carrier status phenotype we want to investigate.

### Step 2: Fit models and visualize with a forest plot

Next, we fit logistic regression models using `build_model()`, then
visualize the estimated effect sizes using `forest_plot()`:

```{r}
variant_assoc_result <- build_model(
  df_list_sel,
  outcomes = "phenotype",
  model    = "logistic"
)

fp <- forest_plot(
  variant_assoc_result,
  label_col   = "table_id",
  facet_col   = "phenotype",
  show_errors = TRUE
)
fp
```

**Interpreting the forest plot**

In this forest plot:

* Each row corresponds to one variant in `variants_df`.
* The point shows the estimated log-odds or odds ratio (depending on the
  plotting options used inside `forest_plot()`), and the horizontal line
  shows its confidence interval.
* The vertical reference line represents “no effect” (e.g. odds ratio =
  1 on the original scale).

Because we are using a small toy VCF, the associations are not meant to
be biologically meaningful. Instead, the plot demonstrates how the
package can display effect sizes and uncertainty for a set of variants
being modeled jointly.

## Genome-wide (single-variant) association: phenotype ~ all variants

The core GWAS-style analysis is performed by `gwas_single()`, which
tests the association between the phenotype and each variant in the
merged data.

### Step 1: Run single-variant regression

```{r}
result <- gwas_single(
  ph,
  pheno_col = "phenotype",
  covars    = NULL,
  id_col    = "sample"
)

head(result, 5)
```

Here, `result` contains one row per variant, with effect size estimates,
standard errors, and p-values. In this toy example, all association
signals come from the synthetic carrier phenotype generated earlier, so
any apparent peaks should be interpreted as purely illustrative.

### Step 2: Visualize GWAS results with a Manhattan plot

We can pass the GWAS results to `manhattan_plot()` to obtain a standard
Manhattan plot:

```{r}
mp <- manhattan_plot(result)
mp
```

**Interpreting the Manhattan plot**

In this plot:

* The x-axis shows genomic position grouped by chromosome.
* The y-axis shows (-\log_{10}(p)), so higher points correspond to
  smaller p-values (stronger evidence against the null).
* Each point is one variant from the toy VCF.

Because the example uses a very small synthetic dataset, the plot is
intended to illustrate the *shape* and interpretation of a Manhattan
plot rather than to highlight real genome-wide significant loci. In a
real analysis, you would look for distinct peaks that exceed a chosen
significance threshold.

## Summary

This vignette has shown how to:

1. Read an annotated VCF file and obtain variant and genotype tables.
2. Generate or import phenotype data and merge it with genotypes.
3. Run single-variant GWAS using `gwas_single()` and visualize results
   with `manhattan_plot()`.
4. Select specific variants, fit gene/region-level models with
   `build_model()`, and display effect sizes in a forest plot.

Together, these steps form a complete mini-pipeline for exploring
variant–phenotype associations using the **VcfAssociation** package.

## Session information

For reproducibility, we record the R session information used to build
this vignette:

```{r sessionInfo}
sessionInfo()
```

*/
